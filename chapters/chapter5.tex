%************************************************
\chapter{Cluster Algorithm}\label{ch:cluster}
%************************************************

\section{Charge clusters}

\subsection*{Charge colormaps}

To get an insight of what happens in topological freezing regime,
it can be useful to find a method to visualize the spatial distribution of the local topological charge,
which was defined as:
\[
    q(s) \equiv \frac{1}{2\pi}\arg U[\mathcal P(s)]
\]
This means that its value can be in $(-1/2,1/2]$,
and every plaquette $\mathcal P(s)$ can either give o positive or negative contibution to the total charge.
The most appropriate way to represent this scenario, is with a diverging colormap, that is,
a colormap made of two contrasting colors with varying lightness and saturation that meet in the middle at an unsaturated color.
Each color represents positive or negative numbers,
with values of lightness and saturation that are perceived by the viewer as monotonically increasing.
In this way, distances between numbers can be visualized as distances between colors.

The diverging colormap chosen to represent the local charges is the \emph{Colobrewer - RdBu} map \cite{colorbrewer}.
To increase the range of visible values, the charges are first mapped using a logarithmic scale.
The typical values of the total charge are of the unit order, and it is the result of the summation of all the $N^2$ local contributions.
For this reason, the scale chosen to visualize the data ranges from $1/N^2$ to $100/N^2$, both in the positive and in the negative directions.
The values in $(-1/N^2,1/N^2)$ are mapped to the central white \emph{zero}. Values that are out of the scale have the same color as extreme values.

However, plotting the colormap of the local charges without preprocessing does not produce useful results (Figure \ref{fig:raw_charge_cmap}).
The values are very erratic, and an internal structure cannot be identified.

\begin{figure}[!htb]
	\centering
    \import{gfx/}{raw_charge_cmap.pgf}
    \caption{Local charge colormap without preprocessing}
    \label{fig:raw_charge_cmap}
\end{figure}

\subsection*{Charge smoothing}

What causes such a behaviour are ultraviolet fluctuations of the lattice local charge on wavelengths of the order of the lattice spacing $a$ \cite{teper:1985},
and they overshadow the typical fluctuations of the continuous charge on a certain wavelength $\rho$. 
This problem can be overcome approaching the continuum limit. Indeed, the lattice spacing becomes $a\ll\rho$,
and the unwanted ultraviolet fluctuations can be erased locally smoothing the fields over distances $\gg a$ but $\ll \rho$.

There are several methods to smooth link variables in Lattice QCD \cite{alexandrou:2017}.
However, in this toy model, the lattice topological charge is already well defined and integer valued.
For this reason, it is sufficient to smooth the local values of the charge to remove ultraviolet fluctuations,
which is easier, since they are simply matrices of values associated with lattice plaquettes.

These matrices can be represented as images, as discussed before,
and this parallelism suggests that the same techniques used to smooth colors in images can be employed to smooth local charge values.

For instance, in image processing, the Gaussian blur is a smoothing algorithm commonly used to remove image noise and for edge detection.
It consists in spreading the color of every pixel to all its neighbouring pixels, using a Gaussian weight, centered in the considered pixel.
The algorithm leaves the choice of the Gaussian $\sigma$ and a cutoff distance, beyond which the color is not spread.
In all following applications, the cutoff distance is set to $4\sigma$.

It is also needed to specify how the algorithm should handle pixels near the edges of the image.
In image processing, this is usually done treating pixels out of the bounds as if they were equal to those on the border.
For the smoothing of the topological charge, the lattice boundary conditions have to be reproduced,
and hence, periodic boundary conditions are implemented.

An example application of the Gussian blur is reported in Figure \ref{fig:cappadocia}, obtained used Scikit-image's Gaussian filter.
It can be seen how the smoothing procedure cancels the local squared structure,
and only the global colored spiral structure is visible with the higher value of $\sigma$.
Furthermore, the spiral is more evident in the blurred images, since the local structure overshadowes it.

\begin{figure}[!htb]
    \centering
    \import{gfx/}{cappadocia.pgf}
    \caption{\emph{Cappadocia Balloon Inflating Wikimedia Commons}, by Benh LIEU SONG, CC BY-SA 3.0}
    \label{fig:cappadocia}
\end{figure}

The parallelism with the ultraviolet fluctuations of the topological charge is evident.
Instead of the three components of the RGB colors, the local charge of a plaquette is spread.

The result of the Gaussian blur applied to the topological charge is reported in Figure \ref{fig:charge_blur}.
With a sufficiently high value of $\sigma$, ultaviolet fluctuations are removed,
and the cluster structure becomes evident.
If $\sigma$ is too high, also the topological charge fluctuations will cancel each others,
and too much information will be lost.

\begin{figure}[!htb]
    \centering
    \import{gfx/}{charge_blur.pgf}
    \caption{Topological charge Gaussian blur}
    \label{fig:charge_blur}
\end{figure}

The optimal values of sigma for the considered lattice spacing have been identified to be between $\sigma=1.5$ and $\sigma=2$.
And this still holds for bigger lattices with the same physical volume.

\subsection*{Topological freezing}
%Now that a method to visualize charge clusters is defined,
%it is possible to get an insight of what is happening in topological freezing regime
Now that a method to visualize charge clusters is defined,
it can be applied to get an insight of what is happening in topological freezing regime.

The history plots of Figure \ref{fig:local_charge_history} show that the fixed physical volume line of Table \ref{tab:local_cont}
heavily suffers from freezing if $N>24$.
Let then consider completely frozen configurations with $N=36,\ \beta=16.2$.

In Figure \ref{fig:freezing}, the blurred charge of four consecutive configurations are reported.
Charge clusters may move in the space or may be deformed,
but their contribution to the total charge remains the same.

\begin{figure}[!htb]
    \centering
    \import{gfx/}{freezing.pgf}
    \caption{Blurred charge maps after four consecutive local sweep updates}
    \label{fig:freezing}
\end{figure}

\subsection*{Charge tunneling}
If a solution to the topological freezing has to be found,
it is instructive to see what happens when charge tunneling is still achievable with a local algorithm.
Let then consider configurations with $N=24,\ \beta=7.2$,
in which the charge correlation time is already becomome high (Figure \ref{fig:local_charge_corr}) due to topological freezing,
but charge tunneling is still not so rare to prevent from collecting independent charge configurations.

The blurred charge maps after four consecutive sweeps are reported in Figure \ref{fig:local_inv},
and a charge tunneling has happened between the third and the fourth image.


\begin{figure}[!htb]
    \centering
    \import{gfx/}{local_inv.pgf}
    \caption{Charge tunneling}
    \label{fig:local_inv}
\end{figure}

\section{Cluster inversion}
\subsection*{Inverting links}

\subsection*{Gauge transforms}

\subsection*{Cluster building}

\begin{figure}[!htb]
    \centering
    \import{gfx/}{cluster_inv.pgf}
    \caption{Cluster algorithm inversion}
    \label{fig:cluster_inv}
\end{figure}

\begin{figure}[!htb]
    \centering
    \import{gfx/}{freezing_overcoming.pgf}
    \caption{Topological freezing overcoming with the cluster algorithm}
    \label{fig:freezing_overcoming}
\end{figure}

\begin{lstlisting}[caption={Cluster class declaration}]
class Cluster
{
    public:
        template <class URNG>
        Cluster(int N, int side, URNG&);

        Link gate() const {return gate_;};
        const vector<Link> &path() const {return path_;};
        const Staple &estaple() const {return estaple_;};
        const Staple &istaple() const {return istaple_;};
        vector<Link> links() const;
    private:
        int side;
        Site corner;

        Link gate_;
        vector<Link> path_;
        Staple estaple_, istaple_;
};
\end{lstlisting}

\begin{lstlisting}[caption={Cluster class implementation}]
template <class URNG>
Cluster::Cluster(int N, int side, URNG &rng) :
    side{side}
{
    int ran_pos = UniformInt(0,N*N-1)(rng);
    int x1 = ran_pos/N; // unif in [0,N-1]
    int x2 = ran_pos%N; // unif in [0,N-1]
    corner = Site{x1,x2}; // lower left corner

    int ran_muoff = UniformInt(0,2*4*side-1)(rng);
    int mu = ran_muoff%2 + 1; // unif in [1,2]
    int offset = ran_muoff/2; // unif in [0,4*side-1]

    // Build path
    int nu;
    switch (mu) {
        case 1: nu = 2; break;
        case 2: nu = 1; break;
        default: throw runtime_error("Invalid mu");
    }

    Site s = corner;
    for (int rho : {mu,nu,-mu,-nu}) {
        for (int i=0; i<side; i++) {
            path_.push_back(Link{s,rho});
            s = s + hat(rho);
        }
    }

    // Rotate path and extract gate
    rotate(path_.begin(), path_.begin()+offset, path_.end());
    gate_ = path_[0]; path_.erase(path_.begin());
    
    // Identify staples
    int mu_e; // External direction
    switch (offset/side) {
        case 0: mu_e = -nu; break;
        case 1: mu_e = mu; break;
        case 2: mu_e = nu; break;
        case 3: mu_e = -mu; break;
        default: throw runtime_error("invalid mu");
    }
    estaple_ = conn_staple(gate_,mu_e);
    istaple_ = conn_staple(gate_,-mu_e);
}

vector<Link> Cluster::links() const
{
    vector<Link> vec;

    int x1, x2;
    x2 = corner.x2+1;
    for (; x2<corner.x2+side; x2++) {
        x1 = corner.x1;
        for (; x1<corner.x1+side; x1++) {
            vec.push_back(Link{Site{x1,x2},1});
        }
    }
    x2 = corner.x2;
    for (; x2<corner.x2+side; x2++) {
        x1 = corner.x1+1;
        for (; x1<corner.x1+side; x1++) {
            vec.push_back(Link{Site{x1,x2},2});
        }
    }
    return vec;
}
\end{lstlisting}

\subsection*{Metropolis inversion}

\begin{lstlisting}[caption={Metropolis cluster update}]
template <class URNG>
double naive_cluster_update(Lattice &lat, int side, URNG &rng)
{
    Cluster cluster(lat.N(),side,rng);

    auto path = cluster.path();
    auto link_it = path.rbegin();
    for (; link_it<path.rend(); link_it++) {
        Link link = *link_it;
        cmplx u = lat.s_line(link);
        lat.local_gauge(link.s, conj(u));
    }

    cmplx US_e = lat.s_line(cluster.estaple());
    cmplx u_old = lat.s_line(cluster.gate());
    cmplx u_new = conj(u_old);

    double p = exp(lat.beta()*real(US_e*(u_new-u_old)));

    if (UniformDouble()(rng)<p) {
        lat.set_link(cluster.gate(),u_new);
        for (Link link : cluster.links()) {
            cmplx u = lat.s_line(link);
            lat.set_link(link,conj(u));
        }
        return 1.;
    }
    else return 0.;
}
\end{lstlisting}

\subsection*{Metropolis-Hastings proposal}
\begin{lstlisting}[caption={Metropolis-Hastings cluster update}]
template <class URNG>
double cluster_update(Lattice &lat, int side, URNG &rng)
{
    Cluster cluster(lat.N(),side,rng);

    auto path = cluster.path();
    auto link_it = path.rbegin();
    for (; link_it<path.rend(); link_it++) {
        Link link = *link_it;
        cmplx u = lat.s_line(link);
        lat.local_gauge(link.s, conj(u));
    }
    
    cmplx US_e = lat.s_line(cluster.estaple());
    cmplx US_i = lat.s_line(cluster.istaple());
    cmplx W_new = US_e + conj(US_i);
    cmplx W_old = US_e + US_i;
    
    double k_old = lat.beta()*abs(W_old);
    double k_new = lat.beta()*abs(W_new);

    cmplx u_old = lat.s_line(cluster.gate());
    double x_old = arg(W_old*u_old);
    
    double x_new = gauss_angle(k_new,rng);
    

    double p = exp(k_new*(cos(x_new)+pow(x_new,2.)/2.)
                  -k_old*(cos(x_old)+pow(x_old,2.)/2.))
              *erf(pi*sqrt(k_new/2.))/erf(pi*sqrt(k_old/2.))
              *sqrt(k_old/k_new);
    
    if (UniformDouble()(rng)<p) {
        cmplx u_new = exp(1i*(x_new-arg(W_new)));
        lat.set_link(cluster.gate(),u_new);
        for (Link link : cluster.links()) {
            cmplx u = lat.s_line(link);
            lat.set_link(link,conj(u));
        }
        return 1.;
    }
    else return 0.;
}
\end{lstlisting}

\begin{figure}[!htb]
    \centering
    \import{gfx/}{cluster_acc_cont.pgf}
    \caption{Cluster algorithms acceptance contunuum limit comparison}
    \label{fig:cluster_acc_cont}
\end{figure}

\begin{figure}[!htb]
	\centering
    \import{gfx/}{cluster_side_acc.pgf}
    \caption{Cluster side acceptance comparison}
    \label{fig:cluster_side_acc}
\end{figure}

%*****************************************
%*****************************************
%*****************************************
%*****************************************
%*****************************************
