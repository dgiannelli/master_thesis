%************************************************
\chapter{Cluster Algorithm}\label{ch:cluster}
%************************************************

\section{Charge clusters}

\subsection*{Charge colormaps}

To get an insight of what happens in topological freezing regime,
it can be useful to find a method to visualize the spatial distribution of the local topological charge,
which was defined as:
\[
    q(s) \equiv \frac{1}{2\pi}\arg U[\mathcal P_{12}(s)]
\]
This means that its value can be in $(-1/2,1/2]$,
and every plaquette $\mathcal P_{12}(s)$ can either give o positive or negative contibution to the total charge.
The most appropriate way to represent this scenario, is with a diverging colormap, that is,
a colormap made of two contrasting colors with varying lightness and saturation that meet in the middle at an unsaturated color.
Each color represents positive or negative numbers,
with values of lightness and saturation that are perceived by the viewer as monotonically increasing.
In this way, distances between numbers can be visualized as distances between colors.

The diverging colormap chosen to represent the local charges is the \emph{Colobrewer - RdBu} map \cite{colorbrewer}.
To increase the range of visible values, the charges are first mapped using a logarithmic scale.
The typical values of the total charge are of the unit order, and it is the result of the summation of all the $N^2$ local contributions.
For this reason, the scale chosen to visualize the data ranges from $1/N^2$ to $100/N^2$, both in the positive and in the negative directions.
The values in $(-1/N^2,1/N^2)$ are mapped to the central white \emph{zero}. Values that are out of the scale have the same color as extreme values.

However, plotting the colormap of the local charges without preprocessing does not produce useful results (Figure \ref{fig:raw_charge_cmap}).
The values are very erratic, and an internal structure cannot be identified.

\begin{figure}[!htb]
	\centering
    \import{gfx/}{raw_charge_cmap.pgf}
    \caption{Local charge colormap without preprocessing}
    \label{fig:raw_charge_cmap}
\end{figure}

\subsection*{Charge smoothing}

What causes such a behaviour are ultraviolet fluctuations of the lattice local charge on wavelengths of the order of the lattice spacing $a$ \cite{teper:1985},
and they overshadow the typical fluctuations of the continuous charge on a certain wavelength $\rho$. 
This problem can be overcome approaching the continuum limit. Indeed, the lattice spacing becomes $a\ll\rho$,
and the unwanted ultraviolet fluctuations can be erased locally smoothing the fields over distances $\gg a$ but $\ll \rho$.

There are several methods to smooth link variables in Lattice QCD \cite{alexandrou:2017}.
However, in this toy model, the lattice topological charge is already well defined and integer valued.
For this reason, it is sufficient to smooth the local values of the charge to remove ultraviolet fluctuations,
which is easier, since they are simply matrices of values associated with lattice plaquettes.

These matrices can be represented as images, as discussed before,
and this parallelism suggests that the same techniques used to smooth colors in images can be employed to smooth local charge values.

For instance, in image processing, the Gaussian blur is a smoothing algorithm commonly used to remove image noise and for edge detection.
It consists in spreading the color of every pixel to all its neighbouring pixels, using a Gaussian weight, centered in the considered pixel.
The algorithm leaves the choice of the Gaussian $\sigma$ and a cutoff distance, beyond which the color is not spread.
In all following applications, the cutoff distance is set to $4\sigma$.

It is also needed to specify how the algorithm should handle pixels near the edges of the image.
In image processing, this is usually done treating pixels out of the bounds as if they were equal to those on the border.
For the smoothing of the topological charge, the lattice boundary conditions have to be reproduced,
and hence, periodic boundary conditions are implemented.

An example application of the Gussian blur is reported in Figure \ref{fig:cappadocia}, obtained used Scikit-image's Gaussian filter.
It can be seen how the smoothing procedure cancels the local squared structure,
and only the global colored spiral structure is visible with the higher value of $\sigma$.
Furthermore, the spiral is more evident in the blurred images, since the local structure overshadowes it.

\begin{figure}[!htb]
    \centering
    \import{gfx/}{cappadocia.pgf}
    \caption{\emph{Cappadocia Balloon Inflating Wikimedia Commons}, by Benh LIEU SONG, CC BY-SA 3.0}
    \label{fig:cappadocia}
\end{figure}

The parallelism with the ultraviolet fluctuations of the topological charge is evident.
Instead of the three components of the RGB colors, the local charge of a plaquette is spread.

The result of the Gaussian blur applied to the topological charge is reported in Figure \ref{fig:charge_blur}.
With a sufficiently high value of $\sigma$, ultaviolet fluctuations are removed,
and the cluster structure becomes evident.
If $\sigma$ is too high, also the topological charge fluctuations will cancel each others,
and too much information will be lost.

\begin{figure}[!htb]
    \centering
    \import{gfx/}{charge_blur.pgf}
    \caption{Topological charge Gaussian blur}
    \label{fig:charge_blur}
\end{figure}

The optimal values of sigma for the considered lattice spacing have been identified to be between $\sigma=1.5$ and $\sigma=2$.
And this still holds for bigger lattices with the same physical volume.

\subsection*{Topological freezing}
%Now that a method to visualize charge clusters is defined,
%it is possible to get an insight of what is happening in topological freezing regime
Now that a method to visualize charge clusters is defined,
it can be applied to get an insight of what is happening in topological freezing regime.

The history plots of Figure \ref{fig:local_charge_history} show that the fixed physical volume line of Table \ref{tab:local_cont}
heavily suffers from freezing if $N>24$.
Let then consider completely frozen configurations with $N=36,\ \beta=16.2$.

In Figure \ref{fig:freezing}, the blurred charge of four consecutive configurations are reported.
Charge clusters may move in the space or may be deformed,
but their contribution to the total charge remains the same.

\begin{figure}[!htb]
    \centering
    \import{gfx/}{freezing.pgf}
    \caption{Blurred charge maps after four consecutive local sweep updates}
    \label{fig:freezing}
\end{figure}

\subsection*{Charge tunneling}
If a solution to the topological freezing has to be found,
it is instructive to see what happens when charge tunneling is still achievable with a local algorithm.
Let then consider configurations with $N=24,\ \beta=7.2$,
in which the charge correlation time is already becomome high (Figure \ref{fig:local_charge_corr}) due to topological freezing,
but charge tunneling is still not so rare to prevent from collecting independent charge configurations.

The blurred charge maps after four consecutive sweeps are reported in Figure \ref{fig:local_inv},
and a charge tunneling has happened between the third and the fourth image.
A new cluster of negative red values has risen in a region in which a positive blue cluster was present,
and the topological charge moves from $Q=0$ to $Q=-1$.

\begin{figure}[!htb]
    \centering
    \import{gfx/}{local_inv.pgf}
    \caption{Charge tunneling with a local algorithm}
    \label{fig:local_inv}
\end{figure}

The idea of the cluster algorithm is then to create a Metropolis move that emulates this \emph{spontaneous} charge tunneling,

\section{Cluster inversion}

\subsection*{Inverting links}

Transforming each link variable inside a plaquette to its complex conjugate
has the effect of reversing the value of its local topological charge (Equation \eqref{eq:lat_loc_top_charge}):
\[\begin{aligned}
    q(s) &= \frac{1}{2\pi}\arg U[\mathcal P_{12}(s)] \\
         &\mapsto \frac{1}{2\pi}\arg U^*[\mathcal P_{12}(s)] = -q(s)
\end{aligned}\]
It has the same effect of taking the plaquette in the opposite direction:
\[
    U[\mathcal P_{21}(s)] = U^*[\mathcal P_{12}(s)]
\]

The plaquette energy is instead invariant under links conjugation:
\[\begin{aligned}
    E(s) &= 1-\Re\,U[\mathcal P_{12}(s)] \\
         &\mapsto 1-\Re\,U^*[\mathcal P_{12}] = E(s)
\end{aligned}\]

In terms of Markov chain sampling and Metropolis algorithm (Equation \ref{eq:acceptance_sym}),
a move that produces zero energy variation is a move that has acceptance one.

Thus, taking the complex conjugate of all links inside a space region does not change the energy of all plaquettes of this region.
What actually changes, and prevents this block move to be an effective Metropolis update,
is the energy of all plaquettes connected to the border links of this region.
Indeed, only one link in them is conjugated, and the energy changes, in general, if this link is not real valued.
It is then very unlikely that the move is accepted if the energies of a high number of plaquettes change all together.

However, there is still another move that leaves the energy and the charge unchanged,
and it is the gauge transformation.

\subsection*{Gauge transformations}
Local gauge transformations of the type of Equation \eqref{eq:site_gauge} and Figure \ref{fig:local_gauge} are now considered.
Each plaquette Wilson loop remains unchanged after such a transformation,
and hence also the topological charge and the energy are invariant.
The goal is then to find an appropriate gauge transformation that minimizes the energy variation of the cluster inversion described before.

It was observed before that if link variables along the border are real valued,
the energy of the corresponding external plaquettes does not change after the cluster inversion.
A possible strategy to reduce the energy variation is to find a set of local gauge transformations that set border link variables to $1$,
and then perform the cluster inversion.

Considering the lattice region of Figure \ref{fig:cluster}, and the link path surrounding it,
let $U_1, U_2, \ldots$ be the Schwinger lines evaluated over links $\mathcal L_1, \mathcal L_2, \ldots$,
and $s_1, s_2, \ldots$ the starting sites of them.
The last link variable of the path, $U_{12}$, can be set to $1$ with the gauge transform of Figure \ref{fig:local_gauge}
with $G=U^*_{12}$ applied on site $s_{12}$.
The only other link variable of the path that is modified by this transformation is the previous one: $U_{11}$.
Applying then another local gauge trasformation with $G=U^*_{11}$ on site $s_{11}$,
also the value of $U_{11}$ can be set to $1$, without modifying the other value already set to $1$.
This sequence can be iterated to set all values $U_1,U_2,\ldots=1$.
However, the same procedure cannot be applied to the last remaining path link, $\mathcal L$,
because it would modify the value $U_{12}$, already set to $1$ with the first transformation.

\subsection*{Reverse cluster algorithm}
After such a chain of gauge transfomations,
reversing all links in the surrounded region would modify only one external plaquette,
the one enclosing the link $\mathcal L$.

The acceptance of the entire move can be evaluated with Equation \eqref{eq:acceptance_sym}





\begin{figure}[!htb]
    \centering
    \begin{tikzpicture}[x=1cm,y=1cm]
        \draw[step=1, help lines, dashed, color=black!30] (0,0) grid (4.5,4.5);
        \draw[->,thick,black] (0,0) -- (4.5,0) node [right] {$x_1$};
        \draw[->,thick,black] (0,0) -- (0,4.5) node [above] {$x_2$};

        %internal links
        %\draw[step=1,color=RoyalBlue] (1,1) grid (3,3);

        %gate
        \draw[->-,very thick,black,dashed] (2,1) -- node [black,above] {$\mathcal L$} (3,1);

        %path
        \draw[->-,very thick,RoyalBlue] (3,1) -- node [black,below] {$\mathcal L_1$} (4,1);
        \draw[->-,very thick,RoyalBlue] (4,1) -- node [black,right] {$\mathcal L_2$} (4,2);
        \draw[->-,very thick,RoyalBlue] (4,2) -- node [black,right] {$\mathcal L_3$} (4,3);
        \draw[->-,very thick,RoyalBlue] (4,3) -- node [black,right] {$\mathcal L_4$} (4,4);
        \draw[->-,very thick,RoyalBlue] (4,4) -- node [black,above] {$\mathcal L_5$} (3,4);
        \draw[->-,very thick,RoyalBlue] (3,4) -- node [black,above] {$\mathcal L_6$} (2,4);
        \draw[->-,very thick,RoyalBlue] (2,4) -- node [black,above] {$\mathcal L_7$} (1,4);
        \draw[->-,very thick,RoyalBlue] (1,4) -- node [black,left] {$\mathcal L_8$} (1,3);
        \draw[->-,very thick,RoyalBlue] (1,3) -- node [black,left] {$\mathcal L_9$} (1,2);
        \draw[->-,very thick,RoyalBlue] (1,2) -- node [black,left] {$\mathcal L_{10}$} (1,1);
        \draw[->-,very thick,RoyalBlue] (1,1) -- node [black,below] {$\mathcal L_{11}$} (2,1);

        %internal staple
        \draw[->-,very thick,Maroon] (3,1) -- (3,2);
        \draw[->-,very thick,Maroon] (3,2) -- node [black,above] {$\mathcal S_i$} (2,2);
        \draw[->-,very thick,Maroon] (2,2) -- (2,1);

        %external staple
        \draw[->-,very thick,Maroon] (3,1) -- (3,0);
        \draw[->-,very thick,Maroon] (3,0) -- node [black,above] {$\mathcal S_e$} (2,0);
        \draw[->-,very thick,Maroon] (2,0) -- (2,1);
    \end{tikzpicture}
    \caption{Cluster of links with its surrounding path}
    \label{fig:cluster}
\end{figure}

\subsection*{Cluster building}

\begin{figure}[!htb]
    \centering
    \import{gfx/}{cluster_inv.pgf}
    \caption{Cluster algorithm inversion}
    \label{fig:cluster_inv}
\end{figure}

\begin{figure}[!htb]
    \centering
    \import{gfx/}{freezing_overcoming.pgf}
    \caption{Topological freezing overcoming with the cluster algorithm}
    \label{fig:freezing_overcoming}
\end{figure}

\begin{lstlisting}[caption={Cluster class declaration}]
class Cluster
{
    public:
        template <class URNG>
        Cluster(int N, int side, URNG&);

        Link gate() const {return gate_;};
        const vector<Link> &path() const {return path_;};
        const Staple &estaple() const {return estaple_;};
        const Staple &istaple() const {return istaple_;};
        vector<Link> links() const;
    private:
        int side;
        Site corner;

        Link gate_;
        vector<Link> path_;
        Staple estaple_, istaple_;
};
\end{lstlisting}

\begin{lstlisting}[caption={Cluster class implementation}]
template <class URNG>
Cluster::Cluster(int N, int side, URNG &rng) :
    side{side}
{
    int ran_pos = UniformInt(0,N*N-1)(rng);
    int x1 = ran_pos/N; // unif in [0,N-1]
    int x2 = ran_pos%N; // unif in [0,N-1]
    corner = Site{x1,x2}; // lower left corner

    int ran_muoff = UniformInt(0,2*4*side-1)(rng);
    int mu = ran_muoff%2 + 1; // unif in [1,2]
    int offset = ran_muoff/2; // unif in [0,4*side-1]

    // Build path
    int nu;
    switch (mu) {
        case 1: nu = 2; break;
        case 2: nu = 1; break;
        default: throw runtime_error("Invalid mu");
    }

    Site s = corner;
    for (int rho : {mu,nu,-mu,-nu}) {
        for (int i=0; i<side; i++) {
            path_.push_back(Link{s,rho});
            s = s + hat(rho);
        }
    }

    // Rotate path and extract gate
    rotate(path_.begin(), path_.begin()+offset, path_.end());
    gate_ = path_[0]; path_.erase(path_.begin());
    
    // Identify staples
    int mu_e; // External direction
    switch (offset/side) {
        case 0: mu_e = -nu; break;
        case 1: mu_e = mu; break;
        case 2: mu_e = nu; break;
        case 3: mu_e = -mu; break;
        default: throw runtime_error("invalid mu");
    }
    estaple_ = conn_staple(gate_,mu_e);
    istaple_ = conn_staple(gate_,-mu_e);
}

vector<Link> Cluster::links() const
{
    vector<Link> vec;

    int x1, x2;
    x2 = corner.x2+1;
    for (; x2<corner.x2+side; x2++) {
        x1 = corner.x1;
        for (; x1<corner.x1+side; x1++) {
            vec.push_back(Link{Site{x1,x2},1});
        }
    }
    x2 = corner.x2;
    for (; x2<corner.x2+side; x2++) {
        x1 = corner.x1+1;
        for (; x1<corner.x1+side; x1++) {
            vec.push_back(Link{Site{x1,x2},2});
        }
    }
    return vec;
}
\end{lstlisting}

\subsection*{Metropolis inversion}

\begin{lstlisting}[caption={Metropolis cluster update}]
template <class URNG>
double naive_cluster_update(Lattice &lat, int side, URNG &rng)
{
    Cluster cluster(lat.N(),side,rng);

    auto path = cluster.path();
    auto link_it = path.rbegin();
    for (; link_it<path.rend(); link_it++) {
        Link link = *link_it;
        cmplx u = lat.s_line(link);
        lat.local_gauge(link.s, conj(u));
    }

    cmplx US_e = lat.s_line(cluster.estaple());
    cmplx u_old = lat.s_line(cluster.gate());
    cmplx u_new = conj(u_old);

    double p = exp(lat.beta()*real(US_e*(u_new-u_old)));

    if (UniformDouble()(rng)<p) {
        lat.set_link(cluster.gate(),u_new);
        for (Link link : cluster.links()) {
            cmplx u = lat.s_line(link);
            lat.set_link(link,conj(u));
        }
        return 1.;
    }
    else return 0.;
}
\end{lstlisting}

\subsection*{Metropolis-Hastings proposal}
\begin{lstlisting}[caption={Metropolis-Hastings cluster update}]
template <class URNG>
double cluster_update(Lattice &lat, int side, URNG &rng)
{
    Cluster cluster(lat.N(),side,rng);

    auto path = cluster.path();
    auto link_it = path.rbegin();
    for (; link_it<path.rend(); link_it++) {
        Link link = *link_it;
        cmplx u = lat.s_line(link);
        lat.local_gauge(link.s, conj(u));
    }
    
    cmplx US_e = lat.s_line(cluster.estaple());
    cmplx US_i = lat.s_line(cluster.istaple());
    cmplx W_new = US_e + conj(US_i);
    cmplx W_old = US_e + US_i;
    
    double k_old = lat.beta()*abs(W_old);
    double k_new = lat.beta()*abs(W_new);

    cmplx u_old = lat.s_line(cluster.gate());
    double x_old = arg(W_old*u_old);
    
    double x_new = gauss_angle(k_new,rng);
    

    double p = exp(k_new*(cos(x_new)+pow(x_new,2.)/2.)
                  -k_old*(cos(x_old)+pow(x_old,2.)/2.))
              *erf(pi*sqrt(k_new/2.))/erf(pi*sqrt(k_old/2.))
              *sqrt(k_old/k_new);
    
    if (UniformDouble()(rng)<p) {
        cmplx u_new = exp(1i*(x_new-arg(W_new)));
        lat.set_link(cluster.gate(),u_new);
        for (Link link : cluster.links()) {
            cmplx u = lat.s_line(link);
            lat.set_link(link,conj(u));
        }
        return 1.;
    }
    else return 0.;
}
\end{lstlisting}

\begin{figure}[!htb]
    \centering
    \import{gfx/}{cluster_acc_cont.pgf}
    \caption{Cluster algorithms acceptance contunuum limit comparison}
    \label{fig:cluster_acc_cont}
\end{figure}

\begin{figure}[!htb]
	\centering
    \import{gfx/}{cluster_side_acc.pgf}
    \caption{Cluster side acceptance comparison}
    \label{fig:cluster_side_acc}
\end{figure}

%*****************************************
%*****************************************
%*****************************************
%*****************************************
%*****************************************
