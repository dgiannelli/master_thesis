%*****************************************
\chapter{Lattice Class Implementation}\label{ch:lattice}
%*****************************************

Nowadays, the availability of data and processing power is boosting more and more scientific research,
and it is driving a shift to computational and data-driven modes of discovery \cite{nielsen:2011}.

Computational scientific literature is, however, still suffering the lack of reproducibility \cite{reproducible:2009}.
It is difficult to verify most of the results presented at conferences and papers.

The sharing of data and code for verification purposes \cite{reproducible:2012}
is widely recognized as the most urgent practice that has to be adopted.

The implementation code in computational sciences has an importance that is comparable to the proof in deductive sciences \cite{topten}
and the technical descriptions of experiments in empirical sciences.

It is reported that the main obstacle that prevents code publication is the time it takes to clean up and document the work to prepare it for release and reuse \cite{obstacles}.
The best way to reduce the amount of this work is to use modern programming language techniques to make the code self-explanatory
and the closest possible to the problem that has to be solved \cite{best_pratices}.

Procedural programming, data abstraction, object-oriented and generic programming provide methods to express ideas directly in code:
it is possible to write algorithms in terms of abstract concepts hiding implementation details \cite{stroustrup:2013}.

Since Monte Carlo simulations of lattice gauge theories are, in general, very computationally expensive,
they need an efficient use of computer resources, and, therefore, they are implemented with programming languages that allow low level optimizations.

The most common used languages in this field are then FORTRAN, C and C++.
However, among them, the one that has the most comprehensive and flexible support of modern language features is C++,
especially C++11 and later standards.
It also has the largest standard library,
which allows to express algorithms in terms of well known and optimized objects, 
reducing also the dependency on external libraries.

In this work, the C++17 standard was adopted,
and everything has been implemented in terms of standard library constructs.

In this and later chapters, the exposure and description of data structures and algorithms will be accompained with an implementation in C++17.
Lower level implementation details will be kept hidden with the encapsulation methods the language provides,
and they will be shown in Appendix \ref{ap:code}.

The aim of this chapter is to implement the skeleton of the lattice theory.
It will be done in the form of a lattice class, which will have methods to access its basic objects,
compute and modify its Wilson lines and evaluate operators in terms of them.

The interface the lattice class provides will then be used in Chapters \ref{ch:local} and \ref{ch:cluster} to define the Markov chain algorithms.

\section{Lattice objects}

The first things to define are the most basic data structures, \ie lattice objects,
and the first of them has to be a lattice site and its coordinates:
\begin{lstlisting}[caption={Site type}]
struct Site
{
    int x1;
    int x2;
};
\end{lstlisting}
A lattice link can be identified with a site and a direction $\texttt{dir} \in \{1,2,-1,-2\}$:
\begin{lstlisting}[caption={Link type}]
struct Link
{
    Site site;
    int dir;
};
\end{lstlisting}
The link $\mathcal L_2(0,1)$ will then be {\ttfamily Link\{0,1,2\}}.

A generic lattice path is a sequence of links.
The standard library {\ttfamily vector} is an indefinite sized container of object of the same type,
and it already has methods to iterate over them.
The implementation of a generic lattice path will then be just an alias for a vector of links:
\begin{lstlisting}[caption={Path type}]
using Path = vector<Link>;
\end{lstlisting}

To define the analogous version of the plaquette $\mathcal D(s)$ of Figure \ref{fig:plaq},
it is useful to inherit from the standard library {\ttfamily array},
which is similar to {\ttfamily vector} but has a fixed length at compile time,
enabling then further compiler optimizations.
\begin{lstlisting}[caption={Plaquette type}]
struct Plaq : array<Link,4>
{
    Plaq(Site s) :
        array{Link{s.x1, s.x2, 1},
              Link{s.x1+1, s.x2, 2},
              Link{s.x1+1, s.x2+1, -1},
              Link{s.x1, s.x2+1, -2}}
    {}
};
\end{lstlisting}

\section{Lattice class declaration}

The declaration of the {\ttfamily Lattice} class is now reported.
The implementation will be shown in Appendice \ref{ap:code}.

\begin{lstlisting}[caption={Lattice class}]
class Lattice
{
    public:
        /* Lattice is initialized with its shape,
           i.e. the number of sites in each direction,
           and the value of the action parameter beta */
        Lattice(pair<int,int> shape, double beta);
        double beta() const; 

        /* Vector of all lattice sites.
           Useful for iterating over them: */
        vector<Site> sites() const;

        // Observables:
        double action() const;
        double charge() const;
        double local_charge(Site) const; 

        /* All the following methods are aware of
           boundary conditions and treat appropriately
           values out of bounds */

        using cmplx = complex<double>;
        // Wilson lines:
        cmplx w_line(Link) const;
        cmplx w_line(Plaq) const;
        cmplx w_line(Path) const;

        // Set link variable l to value u:
        void set_link(Link l, cmplx u); 

        // Local gauge transformation G(s):
        void local_gauge(Site s, cmplx G);
        
    private:
        pair<int,int> shape_;
        double beta_;
        vector<Site> sites_;
        vector<double> link_vars; // Link variables data

        /* link_vars indexing:
           (boundaries are implemented here) */
        int idx(Link) const;
};
\end{lstlisting}

%*****************************************
%*****************************************
%*****************************************
%*****************************************
%*****************************************
