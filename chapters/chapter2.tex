%*****************************************
\chapter{Lattice Class Implementation}\label{ch:lattice}
%*****************************************

Nowadays, the availability of data and processing power is boosting more and more scientific research,
and it is driving a shift to computational and data-driven modes of discovery \cite{nielsen:2011}.

Computational scientific literature is, however, still suffering the lack of reproducibility \cite{reproducible:2009}.
It is difficult to verify most of the results presented at conferences and papers.

The sharing of data and code for verification purposes \cite{reproducible:2012}
is widely recognized as the most urgent practice that has to be adopted.

The implementation code in computational sciences has an importance that is comparable to the proof in deductive sciences \cite{topten}
and the technical descriptions of experiments in empirical sciences.

It is reported that the main obstacle that prevents code publication is the time it takes to clean up and document the work to prepare it for release and reuse \cite{obstacles}.
The best way to reduce the amount of this work is to use modern programming language techniques to make the code self-explanatory
and the closest possible to the problem that has to be solved \cite{best_pratices}.

Procedural programming, data abstraction, object-oriented and generic programming provide methods to express ideas directly in code:
it is possible to write algorithms in terms of abstract concepts hiding implementation details \cite{stroustrup:2013}.

Since Monte Carlo simulations of lattice gauge theories are, in general, very computationally expensive,
they need an efficient use of computer resources, and, therefore, they are implemented with programming languages that allow low level optimizations.

The most common used languages in this field are then FORTRAN, C and C++.
However, among them, the one that has the most comprehensive and flexible support of modern language features is C++,
especially C++11 and later standards.
It also has the largest standard library,
which allows to express algorithms in terms of well known and optimized objects, 
reducing also the dependency on external libraries.

In this work, the C++17 standard was adopted,
and everything has been implemented in terms of standard library constructs.

In this and later chapters, the exposure and description of data structures and algorithms will be accompained with an implementation in C++17.
Lower level implementation details will be kept hidden with the encapsulation methods the language provides,
and they will be shown in Appendix \ref{ap:code}.

The aim of this chapter is to implement the skeleton of the lattice theory.
It will be done in the form of a lattice class, which will have methods to access its basic objects,
compute and modify its Wilson lines and evaluate operators in terms of them.

The interface the lattice class provides will then be used in Chapters \ref{ch:local} and \ref{ch:cluster} to define the Markov chain algorithms.

\section{Lattice objects}

The first things to define are the most basic data structures, \ie lattice objects,
and the first of them has to be a lattice site and its coordinates:
\begin{lstlisting}[caption={Site type}]
struct Site
{
    int x1;
    int x2;

    Site operator+(Site s) {
        return Site{x1+s.x1,x2+s.x2};
    }
};

Site hat(int mu)
{
    switch (mu) {
        case 1:; return Site{1,0};
        case -1: return Site{-1,0};
        case 2: return Site{0,1};
        case -2: return Site{0,-1};
        default: throw runtime_error("invalid mu");
    }
}
\end{lstlisting}
A lattice link can be identified with a site and a direction $\texttt{dir} \in \{1,2,-1,-2\}$:
\begin{lstlisting}[caption={Link type}]
struct Link
{
    Site s;
    int mu;
};
\end{lstlisting}
The link $\mathcal L_2(0,1)$ will then be {\ttfamily Link\{0,1,2\}}.

%A generic lattice path is a sequence of links.
%The standard library {\ttfamily vector} is an indefinite sized container of object of the same type,
%and it already has methods to iterate over them.
%The implementation of a generic lattice path will then be just an alias for a vector of links:
%\begin{lstlisting}[caption={Path type}]
%using Path = vector<Link>;
%\end{lstlisting}

To define the analogous version of the plaquette $\mathcal D(s)$ of Figure \ref{fig:plaq},
it is useful to inherit from the standard library {\ttfamily array},
which is similar to {\ttfamily vector} but has a fixed length at compile time,
enabling then further compiler optimizations.
\begin{lstlisting}[caption={Plaquette type}]
using Plaq = array<Link,4>;

Plaq plaq_12(Site s)
{
    return Plaq{Link{s,1},
                Link{s+hat(1),2},
                Link{s+Site{1,1},-1},
                Link{s+hat(2),-2}};
}
\end{lstlisting}

\section{Lattice class declaration}

The declaration of the {\ttfamily Lattice} class is now reported.
The implementation will be shown in Appendice \ref{ap:code}.

\begin{lstlisting}[caption={Lattice class}]
class Lattice
{
    public:
        /* Lattice is initialized with its square side size N
           and the value of the action parameter beta */
        Lattice(int N, double beta);
        int N() const {return N_;}
        double beta() const {return beta_;}
        
        /* Vector of all lattice sites.
           Useful for iterating over them: */
        const vector<Site> &sites() const {return sites_;}
        
        // Observables: 
        double energy() const;
        double charge(Site) const;
        double total_charge() const;
        
        /* All the following methods are aware of
           boundary conditions and treat appropriately
           values out of bounds */
        
        // Compute Schwinger line over a generic Path:
        template <class Path>
        cmplx s_line(Path) const;
        
        // Set link variable link to value u:
        void set_link(Link link, cmplx u);
        
        // Local gauge transformation G(s):
        void local_gauge(Site s, cmplx G);
        
    private:
        int N_;
        double beta_;
        vector<Site> sites_;
        vector<double> link_vars; // Link variables data
        
        /* link_vars indexing:
           (boundaries are implemented here) */
        int idx(Link) const;
};
\end{lstlisting}

\begin{lstlisting}[caption={Lattice constructor}]
Lattice::Lattice(int N, double beta) :
    N_{N}, beta_{beta}, link_vars(2*N*N,1.)
{
    for (int x2=0; x2<N; x2++) {
        for (int x1=0; x1<N; x1++) {
            sites_.push_back(Site{x1,x2});
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={Lattice observables}]
double Lattice::energy() const
{
    double sum = 0.;
    for (Site s : sites())
    {
        sum += 1.-real(s_line(plaq_12(s)));
    }
    return beta()*sum/pow(N(),2);
}

double Lattice::charge(Site s) const
{
    return arg(s_line(plaq_12(s)))/2./pi;
}

double Lattice::total_charge() const
{
    double sum = 0.;
    for (Site s : sites())
    {
        sum += charge(s);
    }
    return sum;
}
\end{lstlisting}

\begin{lstlisting}[caption={Link indexing}]
int Lattice::idx(Link link) const
{
    auto [x1,x2] = link.s;
    
    int axis = 0;
    switch (link.mu) {
        case 1: break;
        case -1: x1--; break;
        case 2: axis = 1; break;
        case -2: x2--; axis = 1; break;
        default: throw runtime_error("Invalid mu");
    }

    // Apply periodic boundary to coord x:
    x1 = (x1%N()+N()) % N();
    x2 = (x2%N()+N()) % N();
    
    return x1 + x2*N() + axis*pow(N(),2);
}
\end{lstlisting}

\begin{lstlisting}[caption={Schwinger lines}]
template <>
cmplx Lattice::s_line(Link link) const
{
    cmplx u = exp(1i*link_vars[idx(link)]);
    if (link.mu>0) return u;
    else return conj(u);
}

template <class Path>
cmplx Lattice::s_line(Path path) const
{
    cmplx prod = 1.;
    for (auto link : path)
    {
        prod *= s_line(link);
    }
    return prod;
}
\end{lstlisting}

\begin{lstlisting}[caption={Link updating}]
void Lattice::set_link(Link link, cmplx u)
{
    if (link.mu < 0) u = conj(u);
    link_vars[idx(link)] = arg(u);
}
\end{lstlisting}

\begin{lstlisting}[caption={Local gauge transform}]
void Lattice::local_gauge(Site s, cmplx G)
{
    for (int mu : {1,2,-1,-2}) {
        Link link = Link{s,mu};
        set_link(link, G*s_line(link));
    }
}
\end{lstlisting}


%*****************************************
%*****************************************
%*****************************************
%*****************************************
%*****************************************
